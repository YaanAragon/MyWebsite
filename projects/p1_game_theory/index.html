<!DOCTYPE html>
<html lang="en">
<head>
  <!-- Cookiebot (must be first in <head>) -->
  <script id="Cookiebot"
    src="https://consent.cookiebot.com/uc.js"
    data-cbid="0a9e2c4e-c6d5-4b71-9e14-b4fdc20c48b8"
    data-blockingmode="auto"
    type="text/javascript">
  </script>

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-WRMFW9VXZL"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-WRMFW9VXZL');
  </script>

  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>My game theory simulations</title>

  <!-- Your global site CSS -->
  <link rel="stylesheet" href="/css/style.css" />
  <!-- Page-specific modern styles -->
  <link rel="stylesheet" href="./css/game-theory.css" />

  <!-- D3 and your chart helper stay as they were -->
  <script src="https://d3js.org/d3.v7.js"></script>
  <script src="./js/draw_line_chart.js"></script>
</head>

<body class="page-project-white">
  <!-- Topbar with Back button -->
  <header class="topbar">
    <div class="wrap">
      <a class="back-btn" href="https://aragon.org.uk/index.html" aria-label="Back to homepage">← Back to homepage</a>
      <span class="page-tag">Game Theory</span>
    </div>
  </header>

  <main class="content wrap">
    <!-- Intro -->
    <section class="intro card">
      <h1 class="title">Cooperation, Competition & Simple Rules</h1>
      <p class="lede">
        Why do some groups thrive on trust while others collapse into selfishness? Chapter 8 in the book <em>Nature in Code</em> by Marcel Salathé
        (<a href="https://leanpub.com/natureincode" target="_blank" rel="noopener">Leanpub</a>) explores that question with playful simulations of game theory in action.
        You’ll start with the clash between simple cooperators and defectors, then see how the clever Tit-for-Tat strategy can build lasting partnerships through reciprocity.
        Finally, you’ll discover the adaptable Win-Stay, Lose-Shift approach, where success breeds repetition and failure sparks change.
        These experiments reveal how surprisingly simple rules can explain the rise of cooperation and how quickly it can break down.
      </p>
      <p class="source-note">
        Code draws heavily from the official examples
        (<a href="http://www.natureincode.com/code_examples.html" target="_blank" rel="noopener">natureincode.com/code_examples.html</a>).
      </p>
    </section>

    <!-- Controls -->
    <section class="controls card">
      <h2 class="section-title">Nature in Code, Chapter 8: Cooperation: Good Guys Can Finish First.</h2>

      <!-- Which simulations to load -->
      <fieldset class="nice-fieldset">
        <legend>Which simulations?</legend>
        <label class="choice">
          <input id="chkP1" type="checkbox" checked>
          <span>Part 1 — Cooperators vs Defectors <code>(script_p1.js)</code></span>
        </label>
        <label class="choice">
          <input id="chkP2" type="checkbox" checked>
          <span>Part 2 — Tit for Tat <code>(script_p2.js)</code></span>
        </label>
        <label class="choice">
          <input id="chkP3" type="checkbox" checked>
          <span>Part 3 — Win-Stay, Lose-Shift <code>(script_p3.js)</code></span>
        </label>
      </fieldset>

      <!-- Parameter inputs -->
      <fieldset class="nice-fieldset">
        <legend>Simulation settings</legend>
        <div class="grid">
          <label for="inputC">c</label>
          <input id="inputC" type="number" step="any" value="1">

          <label for="inputB">b</label>
          <input id="inputB" type="number" step="any" value="4">

          <label for="inputPopulation">population_size</label>
          <input id="inputPopulation" type="number" step="1" min="1" value="100">

          <label for="inputSteps">number_of_time_steps</label>
          <input id="inputSteps" type="number" step="1" min="1" value="1000">

          <label for="inputMutation">mutation_rate</label>
          <input id="inputMutation" type="number" step="any" min="0" value="0.001">

          <label for="inputGameRepeats">game_repeats (only part 2)</label>
          <input id="inputGameRepeats" type="number" step="any" min="0" value="100">

          <label for="inputErrorRate">error_rate (only part 3)</label>
          <input id="inputErrorRate" type="number" step="any" min="0" value="0.002">
        </div>

        <p class="hint">
          Defaults: <code>c=1</code>, <code>b=4</code>, <code>population_size=100</code>,
          <code>number_of_time_steps=1000</code>, <code>mutation_rate=0.001</code>,
          <code>game_repeats=100</code> (only part 2), <code>error_rate=0.002</code> (only part 3).
        </p>
      </fieldset>

      <!-- Single control button -->
      <div class="actions">
        <button id="reloadButton" class="btn-primary">Reload</button>
      </div>
    </section>

    <!-- Chart output area -->
    <section class="charts card">
      <h2 class="section-title">Results</h2>
      <div id="chartArea"></div>
    </section>
  </main>

  <!-- Loader logic (unchanged) -->
  <script>
  (function () {
    const demoMap = {
      p1: './js/script_p1.js',
      p2: './js/script_p2.js',
      p3: './js/script_p3.js'
    };

    function clearOldOutputs() {
      document.querySelectorAll('svg').forEach(el => el.remove());
      document.querySelectorAll('body > p').forEach(el => el.remove());
      document.querySelectorAll('[data-demo-script]').forEach(s => s.remove());
    }

    function getNumeric(id, fallback) {
      const v = Number(document.getElementById(id).value);
      return Number.isFinite(v) ? v : fallback;
    }

    function collectSimConfig() {
      return {
        c: getNumeric('inputC', 1),
        b: getNumeric('inputB', 4),
        population_size: Math.max(1, Math.floor(getNumeric('inputPopulation', 100))),
        number_of_time_steps: Math.max(1, Math.floor(getNumeric('inputSteps', 1000))),
        mutation_rate: getNumeric('inputMutation', 0.001),
        number_of_game_repeats: Math.max(1, Math.floor(getNumeric('inputGameRepeats', 100))),
        error_rate: getNumeric('inputErrorRate', 0.002)
      };
    }

    function collectSelection() {
      const sel = [];
      if (document.getElementById('chkP1')?.checked) sel.push('p1');
      if (document.getElementById('chkP2')?.checked) sel.push('p2');
      if (document.getElementById('chkP3')?.checked) sel.push('p3');
      return sel;
    }

    function waitForChartHelper(timeoutMs = 2000, intervalMs = 50) {
      return new Promise((resolve, reject) => {
        const start = Date.now();
        const tick = () => {
          if (typeof window.draw_line_chart === 'function') return resolve();
          if (Date.now() - start >= timeoutMs) return reject(new Error('draw_line_chart is not available'));
          setTimeout(tick, intervalMs);
        };
        tick();
      });
    }

    function loadDemo(src) {
      return new Promise((resolve, reject) => {
        const tag = document.createElement('script');
        tag.src = src;
        tag.async = false;
        tag.setAttribute('data-demo-script', '');
        tag.onload  = () => resolve();
        tag.onerror = () => reject(new Error('Failed to load ' + src));
        document.body.appendChild(tag);
      });
    }

    async function runSelectedOnReload() {
      clearOldOutputs();
      window.simConfig = collectSimConfig();

      try {
        await waitForChartHelper();
      } catch (e) {
        console.error(e);
        alert('The chart library is not loaded yet. Check that D3 and draw_line_chart.js are included.');
        return;
      }

      const selected = collectSelection().map(k => demoMap[k]).filter(Boolean);
      for (const src of selected) {
        await loadDemo(src);
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      document.getElementById('reloadButton').addEventListener('click', runSelectedOnReload);
    });
  })();
  </script>
</body>
</html>
